03-27

필드 선언과 사용 

 필드 선언
	- 필드는 클래스 블록에서 선언되어야 함 
	타입 필드면 [=  초기값];
	- 타입은 필드에 저장할 데이터의 종류를 결정. 기본타입, 참조타입 모두 가능
	- 초기값을 제공하지 않을 경우 필드는 객체 생성 시 자동으로 기본값으로 초기화

 필드 사용 
	- 필드값을 읽고 변경하는 것. 
	클래스로부터 객체가 생성된 후에 필드를 사용할 수 있음
	- 필드는 객체 내부의 생성자와 메소드 내부에서 사용할 수 있고, 
	객체 외부에서도 접근해서 사용할 수 있음.



생성자 선언과 호출 

 기본생성자 	
	- 클래스에 생성자 선언이 없으면 컴파일러는 기본 생성자를 바이트코드 파일에 자동으로 추가 
	[public] 클래스() {     }

 생성자 선언 
	- 객체를 다양하게 초기화 하기 위해 생성자를 직접 선언 할 수 있음
	클래스 ( 매개변수 , ... ) {
	// 객체의 초기화 코드
	}			///* 생성자 블록

	- 생성자는 메소드와 비슷한 모양을 가지고 있으나, 리턴 타입이 없고 클래스 이름과 동일
	- 매개변수의 타입은 매개값의 종류에 맞게 작성

필드 초기화 
	- 객체마다 동일한 값을 갖고 있다면 필드 선언 시 초기값을 대입하는 것이 좋고, 
	객체마다 다른 값을 가져야 한다면 생성자에서 필드를 초기화 하는 것이 좋음 

생성자 오버로딩
	- 매개변수를 달리하는 생성자를 여러개 선언하는 것.
	[생성자 오버로딩] : 매개변수의 타입, 개수, 순서가 다르게 여러 개의 생성자 선언
	
	- 매개변수의 타입, 개수, 선언된 순서가 똑같을 경우 
	매개변수 이름만 바꾸는 것은 생성자 오버로딩이 아님
	
	- 생성자가 오버로딩되어 있을 경우, new 연산자로 생성자를 호출할 때 
	제공되는 매개값의 타입과 수에 따라 실행될 생성자가 결정


다른 생성자 호출 
	- 생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수있음
	- 이 경우 공통 코드를 한 생성자에만 집중적으로 작성하고, 
	나머지 생성자는 this(..)를 사용해 공통 코드를 가진 생성자를 호출


메소드 선언과 호출

메소드 선언 
	- 객체의 동작을 실행 블록으로 정의 하는 것
	(리턴타입 : 메소드가 리턴하는 값의 타입 표시)
	(매개변수 : 메소드가 실행할 때 필요한 매개값을 전달받기 위한 변수)	
	선언부 > 리턴타입 메소트명 (매개변수, .... )  {
	실행할 코드를 작성하는 곳 ( 실행블록)
	}
	- 리턴 타입:  메소드 실행 후 호출한 곳으로 전달하는 결과값의 타입
	- 메소드명 : 메소드명은 첫 문드를 소문자로 시작하고 , 캐멀 스타일로 작성
	- 매개변수 : 메소드를 호출할 때 전달한 매개값을 받기 위해 사용
	- 실행블로 : 메소드 호출 시 실행되는 부분

메소드 호출 
	- 메소드 블록을 실제로 실행하는 것. 
	- 클래스로부터 객체가 생성된 후에 메소드는 생성자와 다른 메소드 내부에서 
	호출될 수 있고, 객체 외부에서도 호출될 수 있음
	- 외부 객체에서 참조 변수와 도트(.) 연산자로 호출

가변길이 매개변수 
	- 메소드가 가변길이 매개변수를 가지고 있다면 
	매개변수의 개수와 상관없이 매개값을 줄 수 있음
		int sum(int... values) {	
		}
	- 메소드 호출 시 매개값을 쉼표로 구분해서 개수와 상관없이 제공할 수 있음
	- 매개값들은 자동으로 배열 항목으로 변환되어 메소드에서 사용됨
		int[] values = {1, 2, 3};
		int result = sum(values);

		int result = sum(new int[] {1, 2, 3} );

return 문
	- 메소드의 실행을 강제 종료하고 호출한 곳으로 돌아간다는 의미
	- 메소드 선언에 리턴 타입이 있을 경우에는 return 문 뒤에 리턴값을 추가로 지정해야함
	- return 문 이후에 실행문을 작성하면 'Unreachable code'라는 컴파일 에러가 발생

메소드 오버로딩 ( 생성자 오버로딩과 개념이 같다, puls , 메소드 오버로딩의 선언에서는 리턴타입은 무관하다.) 
	- 메소드 이름은 같으나 매게변수의 타입, 개수, 순서가 다른 메소드를 여러 개 선언하는 것
 
인스턴스 멤버

인스턴스 멤버 선언 및 사용
	- 인스턴스 멤버: 필드와 메소드 등 객체에 소속된 멤버

this 키워드 
	- 객체 내부에서는 인스턴스 멤버에 접근하기 위해 this를 사용. 
	객체는 자신을 'this'라고 지칭
	- 생성자와 메소드의 매개변수명이 인스턴스 멤버인 필드명과 동일한 경우, 
	인스턴스 필드임을 강조하고자 할 때  this 를 주로 사용

정적 멤버
정적 멤버 선언 
	- 정적멤버 : 메소드 영역의 클래스에 고정적으로 위치하는 멤버
	- static 키워드를 추가해 정정 필드와 정적 메소드로 선언

정적 멤버 사용 
	- 클래스가 메모리로 로딩되면 정적 멤버를 바로 사용할 수 있음. 
	- 클래스 이름과 함께 도트(.) 연산자로 접근
	- 정적 필드와 정정 메소드는 객체 참조 변수로도 접근 

정적 블록
	- 정적 필드를 선언할 때 복잡한 초기화 작업이 필요한다면 정적 블록을 이용
		static {
		}
	- 정적 블록은 클래스가 메모리로 로딩될 때 자동으로 실행
	- 정적 블록이 클래스 내부에 여러 개가 선언되어 있을 경우에는 선언된 순서로 실행
	- 정적 필드는 객체 생성 없이도 사용할 수 있기 때문에 
	생성자에서 초기화 작업을 하지 않음

인스턴스 멤버 사용불가
	- 정적 메소드와 정적 블록은 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수
	없으며 this도 사용할 수 없음.
	- 정적 메소드와 정적 블록에서 인스턴스 멤버를 사용하고 싶다면 
	객체를 먼저 생성하고 참조 변수로 접근

final 필드와 상수
final 필드 선언
	- final 필드는 초기값이 저장되면 최종적인 값이 되어서 프로그램 실행
	도중에 수정할 수 없게 됨.
	- filnal 필드에 초기값을 주려면 필드 선언 시에 
	초기값을 대입하거나 생성자에서 초기값을 대입
		final 타입 필드 [=초기값];

상수 선언 
 	- 상수 : 불변의 값을 저장하는 필드 
	- 상수는 객체마다 저장할 필요가 없고 , 
	여러개의 값을 가져도 안 되기 때문에 static 이면서 final
		static final 타입 상수 [=초기값];

패키지 
자바의 패키지 
	- 클래스의 일부분이며, 클래스를 식별하는 용도
	- 패키지는 주로 개발 회사의 도메인 이름의 역순으로 만듦
	- 상위 패키지와 하위 패키지를 도드(.)로 구분 
	- 패키지에 속한 바이트코드 파일 (~.class)은 따로 
	떼어내어 다른 디렉토리로 이동할 수 없음. 


패키지 선언 
	- 패키지 선언은 package 키워드와 함께 패키지 이름을 기술한 것.
	항상 소스파일 최상단에 위치
	
		package  상위패키지, 하위패키지;
	
		public class 클래스명 {...}

	- 패키지 이름은 모두 소문자로 작성. 패키지 이름이 서로 중복되지
	않도록 회사 도메인 이름의 역순으로 작성하고, 마지막에는 프로젝트 이름을 붙여줌.. 

		com.samsung.projectname
		com.lg.projectname
		org.apache.projectname

import 문 
	- 다른 패키지에 있는 클래스를 사용하려면 import문을 이용해서 
	어떤 패키지의 클래스를 사용하는지 명시 
	- import 문은 패키지 선언과 크래스 선언 사이에 작성. 
	import 키워드 뒤에는 사용하고자 하는 클래스의 전체 이름을 기술


접근 제한자 

접근제한자 	
	- 중요한 필드와 메소드가 외부로 노출되지 않도록 해 객체의 무결성을 
	유지하기 위해서 접근 제한자 사용
	- 접근 제한자는 public, protected, private의 세 가지 종류 

	접근 제한자 	제한 대상 			제한 범위
	public		클래스, 필드, 생성자, 메소드 	없음
	protected		필드, 생성자, 메소드 		같은 패키지이거나, 자식객체만 사용가능.
	(default)		클래스, 필드, 생성자, 메소드 	같은 패키지
	provate 		필드, 생성자, 메소드 		객체 내부

클래스의 접근 제한 
	- 클래스를 선언할 때 public 접근 제한자를 생략하면 클래스는 
	다른 패키지에서 사용할 수 없음
	- 클래스를 선언할 때 public 접근 제한자를 붙이면 클래스는 같은 패키지뿐만 아니라 
	다른 패키지에서도 사용할 수 있음

생성자의 접근 제한 
	- 생성자는 public, default, private 접근 제한을 가질 수 있음 

필드와 메소드의 접근제한
	- 필드와 메소드는 public, default, private 접근 제한을 가질 수 있음 

Getter와 Setter 

Setter 
	- 데이터를 검증해서 유효한 값만 필드에 저장하는 메소드 
Getter 
	- 필드값이 객체 외부에서 사용하기에 부적절한 경우, 
	적절한 값으로 변환해서 리턴할 수 있는 메소드  

싱글톤 패턴
	- 생성자를 private 접근 제한해서 외부에서 new 연산자로 생성자를 
	호출할 수 없도록 막아서 외부에서 마음대로 객체를 생성하지 못하게 함
	- 대신 싱글톤 패턴이 제공하는 정적 메소드를 통해 
	간접적으로 객체를 얻을 수 있음. 










==================================================

Memo about .. 

oop 객체지향프로그래밍

클래스 : (객체설계도 Object)
클래스는 객체를 설계하기 위한 설계도.. 
인스턴스 . 
 
객체를 설계화하면 인스턴스가 만들어진다.

클래스는 객체
인스턴스 객체 
클래스는 = 인스턴스 
인스턴스 != 클래스 

객체의 상호작용 - 	객체의 동작을 호출하면 이루어지고 
		결과값이 리턴되면서 상호작용을 한다.

객체는 상호작용 뿐아니라 그 자체로서 관계를 맺는다 
부모과 자식 객체 [상속관계]
사람과 사물의 [사용관계] 
각 객체간의 [집합관계]

객체지향프로그래밍의 특징


Encapsulation --- > 속성(데이터), 동작(알고리즘)
		: 클래스 안에 서로 연관있는 속성과 기능들을 하나의 
		캡슐로 만들어 데이터를 외부로부터 보호하는 것. 

클래스를 인스턴스화하면 인스턴스(객체)가 만들어진다. 
클래스로부터 객체를 만드는 과정을 인스턴스화라고 함.

클래스 선언
 
접근제한자
Access Modifier : public / private / protected

소스파일당 public class 는 하나만 온다 
나머지 class 는 public 일 수 없다. 

클래스는 type /  type은 변수를 생성할 수 있다.
클래스로부터 객체를 생성하려면 객체 생성 연산자인 new가 필요 . 
new 연산자는 객체를 생성시키고 객체의 주소를 리턴 

클래스변수 = new 클래스 ();

같은 타입이 아닌 다른 타입의 인스턴스(값) 를 저장할 수 없음..

클래스의 구성 멤버
클래스 = 필드, 메소드, 생성자
==================
필드 - 객체의 속성.
메소드 - 객체의 동작.
생성자 - 객체의 초기화. >>>> Random r  = new Random(); // 객체 생성 초기화
	: 한번만 초기화 함. 이 객체를 생성 초기화하는 것을 constructor 
	필드(속성)를 초기화함. 
	클래스 이름과 동일해야한다. 
	Class name () {
		Random r = new Random();
	}


필드 선언 *****
 	1. 자동 초기화.
	2. 

필드변수와 로컬변수는 선언 문법은 같지만 
자동초기화의 유무가 다르다 
생성 시점이 다르고  저장되는 위치, 
메모리가 소멸되는 시점이 다르다. 

필드는 클래스를 인스턴스화 할 때 heap에 생성 된다. 
로컬변수 함수를 콜할 때 만들어진다. 

문법적 기술은 동일하다. 

필드 - heap에 만들어진다. / new 객체 초기화시 생성 / 객체가 회수 될 때 필드가 사라진다/ 자동초기화
로컬변수 - Stack에 만들어진다. / 함수를 call 할 때 생성 / 메소드(함수) 종료될 때 사라진다/ 초기화 되지 않는다. 

객체는 언제 사라지나?  : 필드는 new 객체 생성 초기화시에 생성되는데  필드가 더 이상
		사용되지 않고 고아객체가 될 시에 사라진다.  Gabage collector 가 회수.. 
		언제 고아객체가 되나? 참조를 잃게 되면 .   


로컬변수와 필드의 구별을 해야함. ***** 중요. 

필드 사용 
필드값을 읽고 변경하는 것. 
클래스로부터 객체가 생성된 후에 필드를 사용할 수 있음.
필드는 객체 내부의 생성자와 메소드 내부에서 사용할 수 있고, 
객체 외부에서도 접근해서 사용할 수 있음. 


외부객체 . 도트연산자 사용. 

객체내부에서 로컬변수와 필드의 네임이 같을 땐 
필드에 this. 을 사용해서 구별해준다. 



생성자는 반드시 하나는 존재함. 
[public] 클래스() { } 		// defualt 생성자 


개발자가 기본 생성자를 하나도 만들지 않으면 
컴파일러가 자동으로 기본생성자를 생성한다. 

생성자 오버로딩 	오버로딩은 메소드와 생성자에 적용된다
같은 이름의 생성자와 메소드를 여러게 정의하는 것 = 오버로딩. 

매개변수를 달리하는 생성자를 여러 개 선언하는 것

*********오버로딩

오버로딩 규칙 ( 갯수, 타입, 순서)
1. 매개변수의 갯수가 다르거나 
2. 매개변수의 타입이 다르거나 
3. 매개변수의 순서가 다르거나 
 
F3 을 눌려서 각 override 확인가능. ... 

 what is overloading : 같은 클래스 안에 같은 이름의 메서드를 여러 개 정의 가능한 것. 

필드와 오버로딩 *****
필드는 오버로딩 할 수 없다. 

코드 중복을 해소하기 위해서 다른 생성자를 호출한다. this(..) 를 사용. 
 
코드가 중복되는 것은 비효율과 오류를 많이 생성하기 때문에 
중복을 피하고 최소화해야한다. 
 

메소드는 생성자와는 달리 [리턴]이 존재한다. 
메소드는 리턴 타입을 생략할 수 없다 void라도 써줘야 함. 

리턴은 변수를 호출 한 쪽으로 값을 되돌리고자 할 때 사용.  


static 
스테틱 멤버(정적)와 인스턴스 
 로컬 변수는  stack / 필드는 heap에 만들어짐. 
 static은 new와 아무 연관 관계가 없고 한번만 만들어짐.  (공유변수, 전역변수 처럼 사용)



변수 3가지 
로컬변수 / 필드의 인스턴스필드와  정적 멤버 구분이 가능해야함 

필드는 두 가지 : 인스턴스 필드/ 정적 필드 

자바의 패키지는 디렉토리 개념과 유사하다 / 폴더로 분리하고 안에 파일들이 저장되는 것 처럼.. 
패키지는 프로그램의 충돌 또는 오류를 사전에 방지한다. 

패키지에 소속되어 있으면 패키지의 풀네임으로 실행시켜야 한다. 

oop 에서 필드(속성) private으로 권장. 
대신 setter와 getter를 오픈..  

